import fs from 'fs-extra';
import { Parser } from 'json2csv';
import path from 'path';

import { format } from 'date-fns';
import { ServiceClient } from '../../clients/services.client';
import { env } from '../../config/env';
import logger from '../../config/logger';
import {
  ReportGenerationFailedPublisher,
  ReportGenerationSucceededPublisher,
} from '../../events/publisher';
import { PdfGenerationService } from '../../services/pdf-generation.service';
import { EnrichedStudentPerformance, StudentPerformance } from '../../types';

interface ReportJobPayload {
  jobId: string;
  requesterId: string;
  reportType: string;
  format: 'csv' | 'pdf';
  payload: StudentPerformance[];
}

export class ReportProcessor {
  private readonly successPublisher: ReportGenerationSucceededPublisher;
  private readonly failurePublisher: ReportGenerationFailedPublisher;

  constructor() {
    this.successPublisher = new ReportGenerationSucceededPublisher();
    this.failurePublisher = new ReportGenerationFailedPublisher();
  }

  private async enrichData(
    payload: StudentPerformance[]
  ): Promise<EnrichedStudentPerformance[]> {
    const userIds = [...new Set(payload.map((p) => p.userId))];
    const courseIds = [...new Set(payload.map((p) => p.courseId))];

    if (userIds.length === 0 || courseIds.length === 0) {
      return [];
    }

    const [userMap, courseMap] = await Promise.all([
      ServiceClient.fetchUserProfiles(userIds),
      ServiceClient.fetchCourseDetails(courseIds),
    ]);

    return payload.map((p) => {
      const user = userMap.get(p.userId);
      const course = courseMap.get(p.courseId);

      return {
        name: user
          ? `${user.firstName || ''} ${user.lastName || ''}`.trim()
          : 'Unknown User',
        courseTitle: course?.title || 'Unknown Course',
        progressPercentage: p.progressPercentage,
        averageGrade: p.averageGrade,
        lastActive: p.lastActive ? format(new Date(p.lastActive), 'PP') : 'N/A',
      };
    });
  }

  public async process(data: ReportJobPayload): Promise<void> {
    logger.info(`Processing report generation job: ${data.jobId}`);

    try {
      if (data.reportType !== 'student_performance') {
        throw new Error('Unsupported report type.');
      }

      if (!data.payload || data.payload.length === 0) {
        logger.warn(
          `Job ${data.jobId} has no data to process. Marking as successful with empty report.`
        );
        await this.successPublisher.publish({
          jobId: data.jobId,
          requesterId: data.requesterId,
          fileUrl: '',
          reportType: data.reportType,
          format: data.format,
        });
        return;
      }

      const enrichedPayload = await this.enrichData(data.payload);

      let fileBuffer: Buffer;
      let contentType: string;
      let fileExtension: string;

      if (data.format === 'csv') {
        const csvPayload = enrichedPayload.map((item) => ({
          ...item,
          '---': 'Generated by LearnSphere', // Placeholder column
        }));

        const json2csvParser = new Parser();
        const csv = json2csvParser.parse(csvPayload);

        fileBuffer = Buffer.from(csv, 'utf-8');
        contentType = 'text/csv';
        fileExtension = 'csv';
      } else if (data.format === 'pdf') {
        fileBuffer =
          await PdfGenerationService.generateStudentPerformanceReport(
            enrichedPayload
          );
        contentType = 'application/pdf';
        fileExtension = 'pdf';
      } else {
        throw new Error(`Unsupported format: ${data.format}`);
      }

      // --- LOCAL TESTING & SIMULATION ---
      const localTempDir = path.join(process.cwd(), 'learnsphere-reports');
      await fs.ensureDir(localTempDir);

      const localFilePath = path.join(
        localTempDir,
        `${data.jobId}.${fileExtension}`
      );

      await fs.writeFile(localFilePath, fileBuffer);
      logger.info(
        `[SIMULATION] Report saved locally for verification: ${localFilePath}`
      );
      // --- END LOCAL TESTING ---

      const reportsBucket = env.AWS_PROCESSED_MEDIA_BUCKET;
      const fileKey = `reports/${data.requesterId}/${data.jobId}.${fileExtension}`;

      /*
      // --- REAL AWS S3 UPLOAD ---
      logger.info(`Uploading ${fileExtension} to s3://${reportsBucket}/${fileKey}`);
      await S3ClientService.uploadBuffer(
        reportsBucket,
        fileKey,
        fileBuffer,
        contentType,
        'private'
      );
      const downloadUrl = await S3ClientService.getPresignedDownloadUrl(
        reportsBucket,
        fileKey
      );
      */

      // PLACEHOLDER
      const fakeDownloadUrl = `https://fake-s3.com/${fileKey}`;

      await this.successPublisher.publish({
        jobId: data.jobId,
        requesterId: data.requesterId,
        fileUrl: fakeDownloadUrl, // In production, this would be `downloadUrl`
        reportType: data.reportType,
        format: data.format,
      });

      logger.info(`Successfully processed report for job: ${data.jobId}`);
    } catch (err) {
      const error = err as Error;
      logger.error(`Failed to process report job ${data.jobId}`, {
        error: error.message,
      });

      await this.failurePublisher.publish({
        jobId: data.jobId,
        requesterId: data.requesterId,
        reason: error.message,
      });
    }
  }
}
